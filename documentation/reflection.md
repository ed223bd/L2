# Reflektioner

## Reflektion över namngivning

| Namn          | Förklaring         | Reflektion och regler från Clean Code  |
|---------------|--------------------|----------------------------------------|
| BarGraph | Namn på klassen som ansvarar för skapandet av ett bar graph diagram. | **Meaningful Distinctions** Denna klass hette tidigare "BarGraphManager", men har senare kommit att ändras till BarGraph. Namnet "Manager" i klassnamnet bidrar inte till att man förstår klassens syfte bättre än om den bara hade haft namnet "BarGraph". "Manager" är ett så kallat noise word. I stycket med rubrik **Class Names** framkommer det att man bör undvika "Manager" specifikt. |
| xLabelPosition | Variablel i funktionen createBarGraph i BarGraph klassen. | **Use Intention-Revealing Names** i variabelnamnet framgår att xLabelPosition är x-positionen för Label. Variabelnamnet följer regeln **Use Pronounceable Names** i och med att det är lätt uttala och därmed lätt att använda i diskussioner med andra programmerare. |
| barWidth | Variabel i funktionen createBarGraph i BarGraph klassen. |**Use Searchable Names** Variabelnamnet är lätt att söka efter, för det förekommer ingen annan variabel, funktion eller klass med ett liknande namn. | 
| createLineGraph | Namn på publik funktion i LineGraph klassen. | **Use Intention-Revealing Names** i namnet framgår att funktionen skapar ett diagram. Funktionen har dock ett till syfte, att göra vissa uträkningar. Detta framgår inte i funktionsnamnet och ett mer förklarande namn hade kunnat vara calculateAndCreateLineGraph. **Don't be cute** Funktionsnamnet följer denna regel, då det är ett namn som alla kan förstå och som ger en ledtråd till dess syfte. Om namnet hade varit "connectTheDots" hade det brutit mot regeln, då det namnet kanske är kul för några få utvecklare men det är inte logiskt för alla. "connectTheDots" låter mer som ett namn på en rolig app! |
| highestValue | Namn på en variabel i createBarGraph i BarGraph klassen. | **Add Meaningful Context** Variabelnamnet highestValue är tydligt i sitt sammanhang, där det definieras som det högsta värdet i data-parameterns objekt. Om vi tar variabelnamnet ur sitt sammanhang, blir det plötligt otydligt vad det är highestValue syftar till. Ett bättre namn hade varit "highestValueInDataArray". |

### Reflektion över kapitel 2 av Clean Code

Boken Clean Code nämner många regler kring namngivning, som *Don't be cute*, *Use Intention-Revealing Names* och *Add Meaningful Context*. Det är flera regler som alla pekar på samma sak, att namn på klasser, metoder och variabler ska vara logiska. Så många som möjligt ska kunna tolka namnet och namnets syfte rätt. Namn ska inte sättas för att vara roliga eller som bara personer inom en viss kultur eller socialt sammanhang förstår.

Boken tar även upp att det är viktigt att använda ett ord per innebörd, *Pick One Word Per Concept*. Det betyder att man ska använda samma ord, exempelvis "add", "create" eller "draw" för ett visst syfte. I min kod har jag delat upp "create" och "draw", i att "create" räknar något och ritar (mer övergripande, generell). Det kan innebära att en create-metod gör en uträkning och ritar ut en del av diagrammet, eller att create-funktion kallar på en mer specifik draw-funktion. Ett mer förklarande namn för create-funktionen "createBarGraph" hade kunnat vara "calculateValuesAndDrawBarGraph". Jag valde att använda det kortare namnet "createBarGraph" för att det känns bättre lämpat att visa i det publika interface som en apputvecklare kommunicerar med när de vill använda modulen.



## Reflektion över funktioner

| Namn  | Funktionens plats  | Antal kodrader | Reflektion och regler från Clean Code  |
|---------------|--------------------|------|---------------------------------------|
| createBarGraph(data, theme, fontSize) | I klassen BarGraph | 16 kodrader | **Do One Thing** Denna funktion bryter mot regeln, då den både gör uträkningar och kallar på de privata funktionerna för ritning. Min tanke var att flera av de privata funktionerna behöver samma parametrar och därför behöver vissa uträkningar göras tidigt i den "orkestrerande" createBarGraph. Därför har den två syften, att göra de uträkningar som används av flera funktioner och att kalla på funktionerna. Om jag inte gjorde uträkningar i createBarGraph, hade flera av de privata metoderna haft samma uträkningar vilket bryter mot en den välkända regeln **Don't Repeat Yourself**(DRY). createBarGraph håller inte till regeln **Function Arguments** då den tar emot flera argument. De tre argument denna funktion tar emot skiljer sig tydligt från varandra och är inte lätt ihopblandade, något som Clean Code menar är viktigt när en funktion tar flera argument. |
| drawBar(x, y, barHeight, barWidth, theme) | I klassen BarGraph | 11 kodrader | **Do One Thing** drawBar gör endast en sak, vilket är att rita en stapel baserat på de parametrar som den tar emot. drawBar bryter dock mot **Function Arguments** då den tar emot 5 parametrar och Clean Code boken säger max 3 parametrar. I detta fall tycker jag att de 5 parametrarna är nödvändiga för att drawBar ska hålla sig till regeln om att endast göra en sak, rita. |
| drawValue(xLabelPosition, yValuePosition, value, theme, fontSize) | I klassen BarGraph | 7 kodrader | **Small** drawValue är en liten funktion, bara sju linjer lång. **Verbs and Keywords** Funktionsnamnet, parat med parameternamnen, gör att det är lätt att tolka vad funktionen gör. Den tar en x och en y-position och på den punkten, ritas värdet ut med det tema och teckenstorlek som användaren valt. |
| drawLine(startingPointX, startingPointY, nextPointX, nextPointY, theme) | I klassen LineGraph. | 9 kodrader | **Have No Side Effects** I det finstilta bryter drawLine mot denna regel, då den först skapar elementet, sedan ritar ut det och till sist lägger till elementet i SVG-elementet. Clean Code förklarar att det är felaktigt, för att någon skulle kunna kalla på drawCircle och bara vilja ha själva ritandet och inte att den exempelvis läggs till i SVG-elementet. Funktionen hade kunnat heta "createLineElementAndDrawAndAddToSVG", men känns som ett orimligt långt namn! Logiken för att skapa elementet eller för att lägga till det i det större SVG-elementet är dock så korta (en rad var), att det kändes mer läsbart att ha de i samma funktion. Jag tycker också att man kan argumentera att de passar där, för att de hör till ritandet av linjen. |
| validateData (rawData) | I klassen Validator | 16 kodrader | **Blocks and Indenting** i validateData finns kontrollsatser i form av if-kontroller och enligt Clean Code borde det endast finnas en rad i en sådan. validateData har korta kontrollsatser och har inte något behov av att delas upp ytterligare. Om det hade funnits ett behov av mer omfattande kontrollsatser, skulle jag ha flyttat ut innehållet i if-kontrollerna till egna funktioner och i if-kontrollen endast kallat på de respektive funktionerna. |

### Reflektion över kapitel 3 av Clean Code

I boken Clean Code nämns regeln *Do one Thing* tidigt. Den syftar till att metoder endast ska ha ett syfte, exempelvis skapa, räkna eller rita. Jag har tidigare tänkt att det är en bra struktur att ha en så kallad "huvudmetod" per klass. Efter att ha läst kapitlet om funktioner inser jag att jag behöver tänka om och istället fokusera på vad varje specifik funktion ska göra. Något som fastnade särskilt, var i slutet av kapitlet där författaren nämner att han sällan skriver koden rätt från början. Istället börjar han ofta med en enda lång funktion, som han sedan refaktoriserar och ger förklarande namn till. 

Författaren nämner också en regel *Extract Try/Catch Blocks*, vilken jag håller med om i de fall det är många rader kod i try-blocket. Han ger dock ett exempel där try-blocket endast är 3 rader långt. I de fall det är en väldigt kort metod, tycker jag att koden är mer lättläst om den inte är uppdelad i flera funktioner då det blir mycket scrollande. Enligt mig är det en skillnad på att dela upp ett try-block och att dela upp en funktion, för att funktioner ska vara namngivna för sitt syfte medan ett try/catch-block alltid heter samma sak.

De regler jag funderat mest kring är *Do One Thing* och *Function Arguments*. I och med att modulens syfte är att rita ut data i form av diagram, har det varit svårt att undvika att funktioner tar emot flera argument. Om det var den regel jag prioriterat högst, hade jag behövt bryta mot regeln att funktioner bara ska göra en sak. Den regel jag haft mest fokus på har varit att funktionerna bara ska göra en enda sak. På grund av detta har jag i sammanhanget av min modul, behövt avvika delvis från regeln om att funktioner inte ska ta många arguement.



## Egen reflektion över kodkvalitet

Det verkar finnas en stor gråzon inom kodkvalitet. I vissa typer av system ska man göra på ett sätt, medan det är helt fel i andra system. Från boken Clean Code framgår det att funktioner endast ska göra en sak, men samtidigt ger författaren exempel på hur man hanterar sido-effekter i en funktion vilken insinuerar att det finns tillfällen då en funktion behöver ha en sido-effekt som den kallar på. 

En lärdom jag tar med mig är att dela upp mina funktioner till mindre delar. Min erfarenhet är att denna utbildning redan från början gett en god insyn i hur man bör namnge variabler och det känns upplyftande att det sätt att namnge som *Clean Code* rekommenderar, är samma sätt som vi har blivit introducerade till tidigt i utbildningen. Det jag tar med mig från den här kursen, gällande namngivning, är att våga bestämma långa namn framförallt på funktioner. För långa variabelnamn kan dock bli stökigt och försämra readability om det används många gånger i ett kodblock. Om det är ett för långt namn på en metod, kan det vara ett gott tecken på att funktionen gör för mycket och att det är hög tid att refaktorera.

Något jag tyckte var särskilt svårt under skapandet av denna modul, var att navigera vilka regler som bör ha prioritet. Jag funderade länge på om jag borde ha brutit ut variabeln *barHeight* i BarGraph och *heightOfPoint* i LineGraph, till en gemensam variabel med ett mer generellt namn. Dessa två har för tillfället samma uträkning, men variabelnamnen skiljer sig åt eftersom *barHeight* endast kommer att användas i BarGraph klassen, och vice versa. Hade jag haft en variabel *heightOfElement* i BaseChart (som både BarGraph och LineGraph importerar), tycker jag att variabelnamnet blir för generellt och det öppnar i sin tur för feltolkningar.

Efter att ha läst i boken och funderat över kodkvalitet i mitt eget projekt, finns det mycket jag hade gjort annorlunda om jag hade börjat om på detta projekt. Jag hade planerat in mer tid för att refaktorisera och ändra namn på metoder. Jag hade bestämt mer beskrivande variabelnamn. Det absolut viktigaste är att jag hade skapat en plan för hur de olika klasserna och metoderna ska samspela, för att ha mer tid till att säkerställa kvalitet i slutet av projektet. Tid att arbeta på kodkvalitet kommer inte att finnas, om man inte planerar in det.

